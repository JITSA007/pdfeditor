<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmartPDF Pro - Advanced Editor By JITSA007</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        window.addEventListener('load', () => {
            if(window.pdfjsLib) {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }
        });
    </script>
    
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/downloadjs@1.4.7/download.min.js"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        body { background-color: #f3f4f6; overflow: hidden; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }

        .pdf-page-container {
            position: relative;
            margin-bottom: 40px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            background: white;
            border-radius: 4px;
        }

        .text-layer {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            overflow: hidden;
            line-height: 1.0;
            pointer-events: none;
        }
        
        .smart-edit-active .text-layer { pointer-events: auto; }

        .text-layer span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: pointer;
            transform-origin: 0% 0%;
            transition: background-color 0.15s ease;
        }

        .smart-edit-active .text-layer span:hover {
            background-color: rgba(37, 99, 235, 0.25);
            outline: 2px solid #2563eb;
            border-radius: 2px;
            z-index: 10;
        }

        .interaction-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20;
            pointer-events: none; 
        }
        /* Enable interaction when tools are active */
        .tools-active .interaction-layer {
            pointer-events: auto;
            cursor: crosshair;
        }

        .added-element {
            position: absolute;
            pointer-events: auto;
            border: 1px dashed transparent;
            z-index: 30;
            display: flex;
            align-items: center;
            background-color: white !important; /* Force opaque background */
            opacity: 1 !important;
        }
        .added-element:hover { border-color: #3b82f6; cursor: move; }
        .added-element.selected { border-color: #2563eb; border-style: solid; box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2); }
        
        .added-text {
            background: transparent;
            border: none;
            outline: none;
            color: black;
            white-space: nowrap;
            padding: 2px;
            margin: 0;
            line-height: 1;
            min-width: 10px;
        }
        
        .added-text.is-bold { font-weight: bold; }

        .font-sans-pdf { font-family: Arial, Helvetica, sans-serif; }
        .font-serif-pdf { font-family: 'Times New Roman', Times, serif; }
        .font-mono-pdf { font-family: 'Courier New', Courier, monospace; }

        .added-whiteout { background-color: white !important; border: 1px solid #e2e8f0; }
        .added-replace { background-color: white !important; }

        .drawing-layer { position: absolute; top: 0; left: 0; z-index: 15; pointer-events: none; }
        .drawing-layer.active { pointer-events: auto; cursor: crosshair; }

        .page-controls {
            position: absolute; top: -45px; left: 50%; transform: translateX(-50%);
            background: #1e293b; color: white; padding: 6px 16px; border-radius: 24px;
            display: flex; gap: 16px; opacity: 0; transition: opacity 0.2s; z-index: 50;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .pdf-page-container:hover .page-controls { opacity: 1; }

        .tool-btn { position: relative; }
        .tool-btn.active { background-color: #eff6ff; color: #2563eb; border-color: #bfdbfe; }
        .tool-btn.active::after {
            content: ''; position: absolute; bottom: -2px; left: 25%; width: 50%; height: 2px;
            background: #2563eb; border-radius: 2px;
        }

        .resize-handle {
            position: absolute; bottom: -4px; right: -4px; width: 8px; height: 8px;
            background: #2563eb; border-radius: 50%; cursor: nwse-resize; display: none;
        }
        .added-element:hover .resize-handle, .added-element.selected .resize-handle { display: block; }

        .spinner {
            width: 40px; height: 40px; border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6; border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="h-screen flex flex-col font-sans text-gray-800">

    <header class="bg-white border-b border-gray-200 px-4 py-2 flex items-center justify-between shadow-sm z-40">
        <div class="flex items-center gap-2">
            <div class="bg-blue-600 p-1.5 rounded-lg">
                <i class="ph-bold ph-file-pdf text-xl text-white"></i>
            </div>
            <h1 class="font-bold text-gray-800 tracking-tight hidden sm:block">SmartPDF <span class="text-blue-600">Pro</span></h1>
        </div>

        <!-- Toolbar -->
        <div class="flex items-center gap-1 bg-gray-50 p-1 rounded-xl border border-gray-200" id="toolbar" style="display:none;">
            <button onclick="setTool('cursor')" id="btn-cursor" class="tool-btn active p-2 rounded-lg transition" title="Move Tool">
                <i class="ph ph-cursor text-lg"></i>
            </button>
            <button onclick="setTool('smart-edit')" id="btn-smart-edit" class="tool-btn p-2 rounded-lg transition text-blue-600" title="Smart Text Replacement">
                <i class="ph ph-magic-wand text-lg"></i>
            </button>
            <button onclick="setTool('text')" id="btn-text" class="tool-btn p-2 rounded-lg transition" title="Add New Text">
                <i class="ph ph-text-t text-lg"></i>
            </button>
            <button onclick="setTool('whiteout')" id="btn-whiteout" class="tool-btn p-2 rounded-lg transition" title="Whiteout">
                <i class="ph ph-eraser text-lg"></i>
            </button>
            <button onclick="setTool('draw')" id="btn-draw" class="tool-btn p-2 rounded-lg transition" title="Sign / Draw">
                <i class="ph ph-pen-nib text-lg"></i>
            </button>
            <button onclick="triggerImageUpload()" class="tool-btn p-2 rounded-lg transition" title="Add Image">
                <i class="ph ph-image text-lg"></i>
            </button>
            <input type="file" id="image-upload" accept="image/*" class="hidden" onchange="handleImageUpload(event)">

            <div class="w-px h-6 bg-gray-300 mx-1"></div>
            
            <!-- Contextual Controls -->
            <div id="element-controls" class="hidden flex items-center gap-2 px-2 border-l border-gray-300">
                <select id="font-family-select" onchange="updateSelectedStyle()" class="bg-white border border-gray-300 rounded text-xs p-1 outline-none">
                    <option value="Sans">Sans-Serif</option>
                    <option value="Serif">Serif (Times)</option>
                    <option value="Mono">Monospace</option>
                </select>
                <div class="flex items-center gap-1">
                    <i class="ph ph-text-aa text-xs text-gray-500"></i>
                    <input type="number" id="font-size-input" onchange="updateSelectedStyle()" class="w-12 bg-white border border-gray-300 rounded text-xs p-1 outline-none" value="16">
                </div>
                <button id="btn-bold" onclick="toggleBold()" class="p-1.5 rounded hover:bg-white border border-transparent transition text-gray-700" title="Bold">
                    <i class="ph-bold ph-text-b text-sm"></i>
                </button>
                <input type="color" id="text-color-input" onchange="updateSelectedStyle()" class="w-6 h-6 border-0 bg-transparent cursor-pointer">
            </div>

            <div class="w-px h-6 bg-gray-300 mx-1"></div>

            <button onclick="undo()" class="p-2 rounded-lg hover:bg-white transition text-gray-600" title="Undo">
                <i class="ph ph-arrow-u-up-left text-lg"></i>
            </button>
            <button onclick="redo()" class="p-2 rounded-lg hover:bg-white transition text-gray-600" title="Redo">
                <i class="ph ph-arrow-u-up-right text-lg"></i>
            </button>
        </div>

        <div class="flex items-center gap-2">
            <div id="upload-section">
                <label class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-medium cursor-pointer transition flex items-center gap-2 text-sm shadow-sm">
                    <i class="ph ph-upload-simple"></i> Upload
                    <input type="file" id="file-upload" accept="application/pdf" class="hidden" onchange="handleUpload(event)">
                </label>
            </div>
            <button id="new-project-btn" onclick="location.reload()" class="hidden bg-gray-100 hover:bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-medium transition text-sm border border-gray-300">
                New
            </button>
            <button id="download-btn" onclick="savePDF()" class="hidden bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-medium transition flex items-center gap-2 text-sm shadow-sm">
                <i class="ph ph-download-simple"></i> Download
            </button>
        </div>
    </header>

    <main class="flex-1 overflow-auto bg-gray-100/50 relative p-8 flex justify-center" id="main-area">
        <div id="welcome-screen" class="flex flex-col items-center justify-center h-full text-center">
            <div class="bg-white p-12 rounded-3xl shadow-xl max-md border border-gray-100">
                <div class="bg-blue-50 w-24 h-24 rounded-full flex items-center justify-center mx-auto mb-6">
                    <i class="ph-duotone ph-file-pdf text-5xl text-blue-600"></i>
                </div>
                <h2 class="text-3xl font-bold mb-2 text-gray-800">Professional PDF Editor</h2>
                <p class="text-gray-500 mb-8">Secure, private, and powerful PDF editing directly in your browser.</p>
                <label class="bg-blue-600 hover:bg-blue-700 text-white px-8 py-4 rounded-xl font-bold cursor-pointer transition inline-flex items-center gap-3 shadow-lg hover:shadow-blue-500/30">
                    <i class="ph-bold ph-plus text-xl"></i> Open File
                    <input type="file" accept="application/pdf" class="hidden" onchange="handleUpload(event)">
                </label>
            </div>
        </div>
        <div id="pdf-container" class="hidden flex flex-col items-center w-full max-w-6xl pb-32"></div>
    </main>

    <div id="loading" class="hidden fixed inset-0 bg-white/80 backdrop-blur-sm z-50 flex flex-col items-center justify-center">
        <div class="spinner mb-4"></div>
        <p class="text-gray-600 font-medium animate-pulse" id="loading-text">Processing Document...</p>
    </div>

    <script>
        const State = {
            pdfDoc: null,
            pdfBytes: null,
            pages: [],
            activeTool: 'cursor',
            scale: 1.5,
            isDrawing: false,
            isDragging: false,
            isResizing: false,
            lastPos: { x: 0, y: 0 },
            selectedElement: null,
            history: [],
            redoStack: [],
            maxHistory: 30
        };

        const UI = {
            welcome: document.getElementById('welcome-screen'),
            container: document.getElementById('pdf-container'),
            toolbar: document.getElementById('toolbar'),
            uploadSection: document.getElementById('upload-section'),
            newProjectBtn: document.getElementById('new-project-btn'),
            downloadBtn: document.getElementById('download-btn'),
            loading: document.getElementById('loading'),
            loadingText: document.getElementById('loading-text'),
            elementControls: document.getElementById('element-controls'),
            fontFamilySelect: document.getElementById('font-family-select'),
            fontSizeInput: document.getElementById('font-size-input'),
            textColorInput: document.getElementById('text-color-input'),
            btnBold: document.getElementById('btn-bold')
        };

        function toggleLoading(show, text = "Processing...") {
            UI.loading.classList.toggle('hidden', !show);
            UI.loadingText.innerText = text;
        }

        // --- Improved History System ---
        function saveToHistory() {
            const domSnapshot = Array.from(document.querySelectorAll('.interaction-layer')).map(l => l.innerHTML);
            const canvasSnapshot = Array.from(document.querySelectorAll('.drawing-layer')).map(c => c.toDataURL());
            
            State.history.push({ dom: domSnapshot, canvas: canvasSnapshot });
            if (State.history.length > State.maxHistory) State.history.shift();
            State.redoStack = [];
        }

        function undo() {
            if (State.history.length <= 1) return;
            const current = State.history.pop();
            State.redoStack.push(current);
            restoreState(State.history[State.history.length - 1]);
        }

        function redo() {
            if (State.redoStack.length === 0) return;
            const next = State.redoStack.pop();
            State.history.push(next);
            restoreState(next);
        }

        function restoreState(state) {
            const intLayers = document.querySelectorAll('.interaction-layer');
            const drawLayers = document.querySelectorAll('.drawing-layer');
            
            intLayers.forEach((l, i) => {
                l.innerHTML = state.dom[i] || '';
                l.querySelectorAll('.added-element').forEach(el => bindElementEvents(el));
            });
            
            drawLayers.forEach((c, i) => {
                const ctx = c.getContext('2d');
                ctx.clearRect(0, 0, c.width, c.height);
                if (state.canvas[i]) {
                    const img = new Image();
                    img.src = state.canvas[i];
                    img.onload = () => ctx.drawImage(img, 0, 0);
                }
            });
            deselectAll();
        }

        async function handleUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            toggleLoading(true, "Opening Document...");
            try {
                State.pdfBytes = await file.arrayBuffer();
                State.pdfDoc = await PDFLib.PDFDocument.load(State.pdfBytes);
                await renderDocument();
                UI.welcome.classList.add('hidden');
                UI.container.classList.remove('hidden');
                UI.toolbar.style.display = 'flex';
                UI.uploadSection.classList.add('hidden');
                UI.newProjectBtn.classList.remove('hidden');
                UI.downloadBtn.classList.remove('hidden');
                saveToHistory();
            } catch (err) {
                alert("Error loading PDF: " + err.message);
            } finally {
                toggleLoading(false);
            }
        }

        async function renderDocument() {
            UI.container.innerHTML = '';
            State.pages = [];
            const pdf = await pdfjsLib.getDocument({ data: State.pdfBytes }).promise;

            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: State.scale });
                const pageId = `page-${i}`;
                
                State.pages.push({
                    id: pageId, originalIndex: i - 1, rotation: 0,
                    width: viewport.width, height: viewport.height,
                    pdfWidth: page.getViewport({ scale: 1 }).width,
                    pdfHeight: page.getViewport({ scale: 1 }).height
                });

                const container = document.createElement('div');
                container.id = pageId;
                container.className = 'pdf-page-container';
                container.style.width = `${viewport.width}px`;
                container.style.height = `${viewport.height}px`;

                const canvas = document.createElement('canvas');
                canvas.className = 'pdf-canvas';
                canvas.width = viewport.width; canvas.height = viewport.height;
                await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;

                const textLayer = document.createElement('div');
                textLayer.className = 'text-layer';
                const textContent = await page.getTextContent();
                
                textContent.items.forEach(item => {
                    const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                    const fontHeight = Math.sqrt((tx[2] * tx[2]) + (tx[3] * tx[3]));
                    const span = document.createElement('span');
                    span.textContent = item.str;
                    span.style.left = `${tx[4]}px`;
                    span.style.top = `${tx[5] - fontHeight}px`;
                    span.style.fontSize = `${fontHeight}px`;
                    
                    let fontType = 'Sans';
                    const name = (item.fontName || '').toLowerCase();
                    if (name.includes('times') || name.includes('serif')) fontType = 'Serif';
                    if (name.includes('courier') || name.includes('mono')) fontType = 'Mono';
                    span.dataset.fontType = fontType;

                    span.onclick = (e) => {
                        if (State.activeTool === 'smart-edit') {
                            e.stopPropagation();
                            initReplacement(span, container.querySelector('.interaction-layer'));
                        }
                    };
                    textLayer.appendChild(span);
                });

                const drawCanvas = document.createElement('canvas');
                drawCanvas.className = 'drawing-layer';
                drawCanvas.width = viewport.width; drawCanvas.height = viewport.height;
                initDrawingEvents(drawCanvas);

                const interactLayer = document.createElement('div');
                interactLayer.className = 'interaction-layer';
                interactLayer.onclick = (e) => {
                    if (State.activeTool === 'text') createTextElement(e, interactLayer);
                    if (State.activeTool === 'whiteout') createWhiteout(e, interactLayer);
                };

                container.append(canvas, textLayer, drawCanvas, interactLayer);
                UI.container.appendChild(container);
            }
        }

        function setTool(tool) {
            State.activeTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${tool}`)?.classList.add('active');
            
            // Manage UI states
            document.body.classList.toggle('smart-edit-active', tool === 'smart-edit');
            document.body.classList.toggle('tools-active', tool === 'text' || tool === 'whiteout');
            
            document.querySelectorAll('.drawing-layer').forEach(l => l.classList.toggle('active', tool === 'draw'));
            deselectAll();
        }

        function deselectAll() {
            document.querySelectorAll('.added-element').forEach(el => el.classList.remove('selected'));
            State.selectedElement = null;
            UI.elementControls.classList.add('hidden');
        }

        function initReplacement(span, layer) {
            const rect = span.getBoundingClientRect();
            const lRect = layer.getBoundingClientRect();
            // Offset a little to cover original text better
            createReplaceBox(rect.left - lRect.left, rect.top - lRect.top, rect.width + 4, rect.height, span.textContent, span.dataset.fontType, layer);
            setTool('cursor');
            saveToHistory();
        }

        function createReplaceBox(x, y, w, h, text, fontType, parent) {
            const el = document.createElement('div');
            el.className = `added-element added-replace font-${fontType.toLowerCase()}-pdf`;
            el.dataset.fontType = fontType;
            el.style.left = `${x}px`; el.style.top = `${y}px`;
            el.style.minWidth = `${w}px`; el.style.minHeight = `${h}px`;

            const input = document.createElement('div');
            input.contentEditable = true;
            input.className = 'added-text';
            input.innerText = text;
            input.style.fontSize = `${h * 0.95}px`;
            input.style.color = 'black';
            
            // Fix pasting to remove formatting
            input.onpaste = (e) => {
                e.preventDefault();
                const text = e.clipboardData.getData('text/plain');
                document.execCommand('insertText', false, text);
            };

            el.appendChild(input);
            el.appendChild(createDelBtn(el));
            parent.appendChild(el);
            
            bindElementEvents(el);
            selectElement(el);
            setTimeout(() => {
                input.focus();
                document.execCommand('selectAll', false, null);
            }, 10);
        }

        function bindElementEvents(el) {
            el.onclick = (e) => { e.stopPropagation(); selectElement(el); };
            makeDraggable(el);
            const input = el.querySelector('.added-text');
            if (input) input.oninput = () => saveToHistory();
        }

        function selectElement(el) {
            deselectAll();
            State.selectedElement = el;
            el.classList.add('selected');
            
            const input = el.querySelector('.added-text');
            if (input) {
                UI.elementControls.classList.remove('hidden');
                UI.fontFamilySelect.value = el.dataset.fontType || 'Sans';
                UI.fontSizeInput.value = parseInt(input.style.fontSize) || 16;
                UI.textColorInput.value = rgbToHex(input.style.color) || '#000000';
                
                // Set bold button state
                if (input.classList.contains('is-bold')) {
                    UI.btnBold.classList.add('bg-white', 'border-gray-300', 'shadow-sm');
                } else {
                    UI.btnBold.classList.remove('bg-white', 'border-gray-300', 'shadow-sm');
                }
            } else {
                UI.elementControls.classList.add('hidden');
            }
        }

        function toggleBold() {
            if (!State.selectedElement) return;
            const input = State.selectedElement.querySelector('.added-text');
            if (!input) return;

            input.classList.toggle('is-bold');
            State.selectedElement.dataset.bold = input.classList.contains('is-bold') ? 'true' : 'false';
            
            if (input.classList.contains('is-bold')) {
                UI.btnBold.classList.add('bg-white', 'border-gray-300', 'shadow-sm');
            } else {
                UI.btnBold.classList.remove('bg-white', 'border-gray-300', 'shadow-sm');
            }
            saveToHistory();
        }

        function rgbToHex(rgb) {
            if (!rgb) return '#000000';
            if (rgb.startsWith('#')) return rgb;
            const res = rgb.match(/\d+/g);
            if (!res) return '#000000';
            return "#" + res.slice(0, 3).map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
        }

        function updateSelectedStyle() {
            if (!State.selectedElement) return;
            const input = State.selectedElement.querySelector('.added-text');
            if (!input) return;

            const font = UI.fontFamilySelect.value;
            State.selectedElement.dataset.fontType = font;
            State.selectedElement.className = State.selectedElement.className.replace(/font-\w+-pdf/g, '');
            State.selectedElement.classList.add(`font-${font.toLowerCase()}-pdf`);
            
            input.style.fontSize = `${UI.fontSizeInput.value}px`;
            input.style.color = UI.textColorInput.value;
            saveToHistory();
        }

        function createTextElement(e, parent) {
            if (e.target !== parent) return;
            const rect = parent.getBoundingClientRect();
            createReplaceBox(e.clientX - rect.left, e.clientY - rect.top, 80, 20, 'New Text', 'Sans', parent);
            setTool('cursor');
            saveToHistory();
        }

        function createWhiteout(e, parent) {
            if (e.target !== parent) return;
            const rect = parent.getBoundingClientRect();
            const el = document.createElement('div');
            el.className = 'added-element added-whiteout';
            el.style.left = `${e.clientX - rect.left}px`;
            el.style.top = `${e.clientY - rect.top}px`;
            el.style.width = '60px'; el.style.height = '18px';
            
            const handle = document.createElement('div');
            handle.className = 'resize-handle';
            initResize(handle, el);

            el.appendChild(handle);
            el.appendChild(createDelBtn(el));
            parent.appendChild(el);
            bindElementEvents(el);
            setTool('cursor');
            saveToHistory();
        }

        function createDelBtn(parent) {
            const b = document.createElement('button');
            b.innerHTML = '<i class="ph ph-x"></i>';
            b.className = 'absolute -top-2.5 -right-2.5 w-5 h-5 bg-red-500 text-white rounded-full flex items-center justify-center text-[10px] opacity-0 group-hover:opacity-100 transition shadow-sm z-50';
            parent.classList.add('group');
            b.onclick = (e) => { e.stopPropagation(); parent.remove(); deselectAll(); saveToHistory(); };
            return b;
        }

        // --- Global Mouse Event Handling ---
        let dragTarget = null, dragSX, dragSY, dragIL, dragIT;
        let resizeTarget = null, resizeSW, resizeSH, resizeSX, resizeSY;

        window.addEventListener('mousemove', (e) => {
            if (State.isDragging && dragTarget) {
                dragTarget.style.left = `${dragIL + (e.clientX - dragSX)}px`;
                dragTarget.style.top = `${dragIT + (e.clientY - dragSY)}px`;
            }
            if (State.isResizing && resizeTarget) {
                resizeTarget.style.width = `${resizeSW + (e.clientX - resizeSX)}px`;
                resizeTarget.style.height = `${resizeSH + (e.clientY - resizeSY)}px`;
                
                const img = resizeTarget.querySelector('img');
                if (img) img.style.width = '100%';
            }
        });

        window.addEventListener('mouseup', () => {
            if (State.isDragging || State.isResizing) {
                saveToHistory();
            }
            State.isDragging = false;
            State.isResizing = false;
            dragTarget = null;
            resizeTarget = null;
        });

        function makeDraggable(el) {
            el.addEventListener('mousedown', (e) => {
                if (State.activeTool !== 'cursor' || e.target.tagName === 'BUTTON' || e.target.classList.contains('resize-handle')) return;
                State.isDragging = true;
                dragTarget = el;
                dragSX = e.clientX; dragSY = e.clientY;
                dragIL = el.offsetLeft; dragIT = el.offsetTop;
            });
        }

        function initResize(handle, el) {
            handle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                State.isResizing = true;
                resizeTarget = el;
                resizeSX = e.clientX; resizeSY = e.clientY;
                resizeSW = el.offsetWidth; resizeSH = el.offsetHeight;
            });
        }

        function initDrawingEvents(canvas) {
            const ctx = canvas.getContext('2d');
            ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2;

            canvas.addEventListener('mousedown', (e) => {
                if (State.activeTool !== 'draw') return;
                State.isDrawing = true;
                const r = canvas.getBoundingClientRect();
                // Ensure starting position is set strictly on mousedown
                State.lastPos = { x: (e.clientX - r.left), y: (e.clientY - r.top) };
                ctx.beginPath();
                ctx.moveTo(State.lastPos.x, State.lastPos.y);
            });

            window.addEventListener('mousemove', (e) => {
                if (!State.isDrawing || State.activeTool !== 'draw') return;
                
                const r = canvas.getBoundingClientRect();
                const x = (e.clientX - r.left);
                const y = (e.clientY - r.top);
                
                // Only draw if cursor is over the active canvas
                if (e.target === canvas) {
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    State.lastPos = { x, y };
                } else {
                    // Update pos so if we re-enter, the line continues from the exit point
                    State.lastPos = { x, y };
                    ctx.moveTo(x, y);
                }
            });

            window.addEventListener('mouseup', () => { 
                if(State.isDrawing) {
                    ctx.closePath();
                    saveToHistory();
                }
                State.isDrawing = false; 
            });
        }

        function triggerImageUpload() { document.getElementById('image-upload').click(); }
        function handleImageUpload(e) {
            const file = e.target.files[0]; if(!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image(); img.src = ev.target.result;
                img.onload = () => {
                    const layer = document.querySelector('.interaction-layer');
                    const el = document.createElement('div');
                    el.className = 'added-element'; el.style.left = '50px'; el.style.top = '50px';
                    img.style.width = '120px'; img.className = 'pointer-events-none block';
                    const h = document.createElement('div');
                    h.className = 'resize-handle';
                    initResize(h, el);
                    
                    el.append(img, h, createDelBtn(el)); layer.appendChild(el);
                    bindElementEvents(el); setTool('cursor');
                    saveToHistory();
                };
            };
            reader.readAsDataURL(file);
        }

        async function savePDF() {
            toggleLoading(true, "Compiling Changes...");
            try {
                const outPdf = await PDFLib.PDFDocument.create();
                
                // Embedding regular and bold font variations
                const fontLibrary = {
                    Sans: {
                        Regular: await outPdf.embedFont(PDFLib.StandardFonts.Helvetica),
                        Bold: await outPdf.embedFont(PDFLib.StandardFonts.HelveticaBold)
                    },
                    Serif: {
                        Regular: await outPdf.embedFont(PDFLib.StandardFonts.TimesRoman),
                        Bold: await outPdf.embedFont(PDFLib.StandardFonts.TimesRomanBold)
                    },
                    Mono: {
                        Regular: await outPdf.embedFont(PDFLib.StandardFonts.Courier),
                        Bold: await outPdf.embedFont(PDFLib.StandardFonts.CourierBold)
                    }
                };

                const containers = document.querySelectorAll('.pdf-page-container');
                for (let container of containers) {
                    const pageData = State.pages.find(p => p.id === container.id);
                    const [page] = await outPdf.copyPages(State.pdfDoc, [pageData.originalIndex]);
                    const newPage = outPdf.addPage(page);
                    const { width, height } = newPage.getSize();
                    const sX = width / pageData.width, sY = height / pageData.height;

                    // 1. Process Drawings
                    const dCanvas = container.querySelector('.drawing-layer');
                    const dData = dCanvas.toDataURL('image/png');
                    if (dData.length > 1000) { 
                        const img = await outPdf.embedPng(dData);
                        newPage.drawImage(img, { x: 0, y: 0, width, height });
                    }

                    // 2. Process Interaction Layer Elements
                    const elements = container.querySelectorAll('.added-element');
                    for (const el of elements) {
                        const ex = el.offsetLeft * sX, ew = el.offsetWidth * sX, eh = el.offsetHeight * sY;
                        const ey = height - (el.offsetTop * sY) - eh;

                        // Force solid white opaque rectangle for whiteout/replace
                        if (el.classList.contains('added-whiteout') || el.classList.contains('added-replace')) {
                            newPage.drawRectangle({ 
                                x: ex, y: ey, width: ew, height: eh, 
                                color: PDFLib.rgb(1, 1, 1),
                                opacity: 1 
                            });
                        }

                        const textDiv = el.querySelector('.added-text');
                        if (textDiv && textDiv.innerText.trim()) {
                            const fontCategory = el.dataset.fontType || 'Sans';
                            const isBold = el.dataset.bold === 'true';
                            const font = isBold ? fontLibrary[fontCategory].Bold : fontLibrary[fontCategory].Regular;
                            
                            const fSize = (parseFloat(textDiv.style.fontSize) || 16) * (width / pageData.pdfWidth);
                            const hex = textDiv.style.color || '#000000';
                            const r = parseInt(hex.slice(1,3), 16)/255, g = parseInt(hex.slice(3,5), 16)/255, b = parseInt(hex.slice(5,7), 16)/255;
                            
                            // Adjust Y baseline for text to feel centered in the masked area
                            const textY = ey + (eh * 0.18); 
                            
                            newPage.drawText(textDiv.innerText, {
                                x: ex + (2 * sX), y: textY,
                                size: fSize, font: font, color: PDFLib.rgb(r || 0, g || 0, b || 0)
                            });
                        }
                        
                        const img = el.querySelector('img');
                        if (img && !el.classList.contains('added-text')) {
                            try {
                                const bytes = await fetch(img.src).then(r => r.arrayBuffer());
                                const embed = await outPdf.embedPng(bytes);
                                newPage.drawImage(embed, { x: ex, y: ey, width: ew, height: eh });
                            } catch(err) { console.error(err); }
                        }
                    }
                }
                const bytes = await outPdf.save();
                download(bytes, "smart_pdf_pro_export.pdf", "application/pdf");
            } catch (e) { alert("Save Error: " + e.message); } finally { toggleLoading(false); }
        }
    </script>
</body>
</html>
